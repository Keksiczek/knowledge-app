"""
presentation.py – /api/presentation endpoint.

POST /api/presentation
Body: { "document_id": "...", "format": "markdown|pptx", "language": "en|cs" }

Returns a Markdown outline or triggers PPTX generation (returned as binary).
"""
from __future__ import annotations

import io
import json
import logging
import re
from typing import Literal

from fastapi import APIRouter, HTTPException
from fastapi.responses import Response, JSONResponse
from pydantic import BaseModel, Field

from .. import database as db
from ..services import llm_service

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api", tags=["presentation"])

MAX_CHARS = 24000  # ~6000 tokens, safe reserve for prompt + response


class PresentationRequest(BaseModel):
    document_id: str
    format: str = Field("markdown", pattern="^(markdown|pptx)$")
    language: str = Field("en", pattern="^(en|cs)$")


def _parse_presentation_json(raw: str) -> dict:
    cleaned = re.sub(r"```(?:json)?\s*", "", raw).strip().rstrip("`").strip()
    try:
        return json.loads(cleaned)
    except json.JSONDecodeError:
        match = re.search(r"\{.*\}", cleaned, re.DOTALL)
        if match:
            try:
                return json.loads(match.group())
            except json.JSONDecodeError:
                pass
    return {"title": "Presentation", "slides": [{"title": "Content", "bullets": [raw], "notes": ""}]}


def _outline_to_markdown(outline: dict) -> str:
    lines = [f"# {outline.get('title', 'Presentation')}\n"]
    for i, slide in enumerate(outline.get("slides", []), 1):
        lines.append(f"## Slide {i}: {slide.get('title', '')}\n")
        for bullet in slide.get("bullets", []):
            lines.append(f"- {bullet}")
        notes = slide.get("notes", "")
        if notes:
            lines.append(f"\n> *{notes}*")
        lines.append("")
    return "\n".join(lines)


def _outline_to_pptx(outline: dict) -> bytes:
    """Build a PPTX file from the LLM-generated outline dict."""
    try:
        from pptx import Presentation as PPTXPresentation
        from pptx.util import Inches, Pt
        from pptx.enum.text import PP_ALIGN
    except ImportError:
        raise HTTPException(
            status_code=501,
            detail="python-pptx not installed. Install it or use format=markdown.",
        )

    prs = PPTXPresentation()
    prs.slide_width = Inches(13.33)
    prs.slide_height = Inches(7.5)

    slide_layouts = prs.slide_layouts

    # Title slide
    title_slide_layout = slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    slide.shapes.title.text = outline.get("title", "Presentation")
    if slide.placeholders[1]:
        slide.placeholders[1].text = "Generated by Knowledge App"

    # Content slides
    bullet_layout = slide_layouts[1]
    for s in outline.get("slides", []):
        slide = prs.slides.add_slide(bullet_layout)
        slide.shapes.title.text = s.get("title", "")
        tf = slide.placeholders[1].text_frame
        tf.clear()
        for j, bullet in enumerate(s.get("bullets", [])):
            if j == 0:
                tf.paragraphs[0].text = bullet
            else:
                p = tf.add_paragraph()
                p.text = bullet
                p.level = 0
        # Add speaker notes
        notes = s.get("notes", "")
        if notes:
            notes_slide = slide.notes_slide
            notes_slide.notes_text_frame.text = notes

    buf = io.BytesIO()
    prs.save(buf)
    return buf.getvalue()


@router.post("/presentation")
async def presentation(req: PresentationRequest):
    """Generate a presentation outline from a document."""
    doc = db.get_document(req.document_id)
    if not doc:
        raise HTTPException(status_code=404, detail="Document not found")
    if doc["status"] != "ready":
        raise HTTPException(
            status_code=409,
            detail=f"Document is not ready yet (status: {doc['status']})",
        )

    # Cache key includes format and language
    cache_extra = f"{req.format}:{req.language}"
    cached = db.get_cached_result(req.document_id, "presentation", cache_extra)
    if cached and req.format == "markdown":
        return {**cached, "cached": True}

    text = db.get_full_text(req.document_id)
    if not text:
        raise HTTPException(status_code=422, detail="No text extracted from document")

    truncated = False
    if not cached:
        # Truncation protection against context window overflow
        original_len = len(text)
        if len(text) > MAX_CHARS:
            half = MAX_CHARS // 2
            text = text[:half] + "\n\n[... střed dokumentu zkrácen ...]\n\n" + text[-half:]
            truncated = True
            logger.warning("Document truncated for LLM: doc_id=%s, original_len=%d", req.document_id, original_len)

        prompt = llm_service.build_presentation_prompt(text, req.language)
        raw = llm_service.generate(prompt)
        outline = _parse_presentation_json(raw)
        result = {
            "document_id": req.document_id,
            "format": req.format,
            "outline": outline,
            "truncated": truncated,
            "cached": False,
        }
        db.save_cached_result(req.document_id, "presentation", result, cache_extra)
    else:
        outline = cached.get("outline", {})
        truncated = cached.get("truncated", False)

    if req.format == "markdown":
        md = _outline_to_markdown(outline)
        return JSONResponse(content={
            "document_id": req.document_id,
            "format": "markdown",
            "markdown": md,
            "outline": outline,
            "truncated": truncated,
            "cached": bool(cached),
        })

    # PPTX binary response
    pptx_bytes = _outline_to_pptx(outline)
    filename = f"{doc['original_name'].rsplit('.', 1)[0]}_presentation.pptx"
    return Response(
        content=pptx_bytes,
        media_type="application/vnd.openxmlformats-officedocument.presentationml.presentation",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'},
    )
